package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/printer"
	"go/token"
	"os"
	"path"
	"strings"
)

const header = `
// Copyright 2025 Muhammed Ali CAN. All rights reserved.
// Use of this source code is governed by the MIT file
// license that can be found in the license file.

// Code generated by "pacis"; DO NOT EDIT.
`

const bundle = `bundle, err := i18n.Setup(messages, language.English)
if err != nil {
	log.Fatal(err)
}
`

const middlewares = `locale := middleware.Locale(bundle, language.English)
auth := middleware.Authentication(AuthHandler)`

const serve = `if mux == nil {
 	mux = http.NewServeMux()
}

pages.SetNotFoundPage(NotFoundPage)

staticfs, _ := fs.Sub(static, "static")
yearcache := middleware.Cache(time.Hour * 24 * 365)
mux.Handle(
 	"GET /static/",
 	yearcache(http.StripPrefix("/static/", http.FileServerFS(staticfs))),
)

for _, route := range routes {
	var handler http.Handler = route
	mux.Handle(route.Path(), handler)
}`

type route struct {
	home        bool
	path        string
	page        string
	layout      string
	middlewares []string

	redirect bool
	to       string
	code     string

	raw     bool
	content string
	typ     string
}

func home(page, layout string, middlewares ...string) route {
	return route{home: true, page: page, layout: layout, middlewares: middlewares}
}

func page(path, page, layout string, middlewares ...string) route {
	return route{path: path, page: page, layout: layout, middlewares: middlewares}
}

func redirect(path, to, code string, middlewares ...string) route {
	return route{redirect: true, path: path, to: to, code: code, middlewares: middlewares}
}

func raw(path, content, typ string, middlewares ...string) route {
	return route{raw: true, path: path, content: content, typ: typ, middlewares: middlewares}
}

type generator struct {
	deps   []string
	embeds []string
	assets map[string]string
	head   []struct {
		path, typ string
	}
	body []struct {
		path, typ string
	}
	routes []route
}

func generate(target string, gen *generator) error {
	fset := token.NewFileSet()

	file := &ast.File{
		Name: &ast.Ident{Name: "app"},
		Doc:  &ast.CommentGroup{
			// List: []*ast.Comment{{Text: header}},
		},
		Decls:   []ast.Decl{},
		Imports: []*ast.ImportSpec{},
	}

	importspecs := []ast.Spec{}
	for _, name := range gen.deps {
		spec := &ast.ImportSpec{
			Path: &ast.BasicLit{
				Kind:  token.STRING,
				Value: "\"" + name + "\"",
			},
		}
		file.Imports = append(file.Imports, spec)
		importspecs = append(importspecs, spec)
	}
	file.Decls = append(file.Decls, &ast.GenDecl{Tok: token.IMPORT, Specs: importspecs})

	embedspec := &ast.GenDecl{
		Tok:   token.VAR,
		Specs: []ast.Spec{},
	}
	for _, embed := range gen.embeds {
		embedspec.Specs = append(embedspec.Specs, &ast.ValueSpec{
			Doc: &ast.CommentGroup{
				List: []*ast.Comment{{Text: "\n//go:embed " + embed}},
			},
			Names: []*ast.Ident{ast.NewIdent(embed)},
			Type:  ast.NewIdent("embed.FS"),
		})
	}
	file.Decls = append(file.Decls, embedspec)

	routerfn := &ast.FuncDecl{
		Name: ast.NewIdent("Router"),
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{
					{
						Names: []*ast.Ident{ast.NewIdent("mux")},
						Type:  ast.NewIdent("*http.ServeMux"),
					},
				},
			},
			Results: &ast.FieldList{
				List: []*ast.Field{{Type: ast.NewIdent("*http.ServeMux")}},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{},
		},
	}

	stmt := func(stmt ast.Stmt) {
		routerfn.Body.List = append(routerfn.Body.List, stmt)
	}

	stmt(&ast.ExprStmt{
		X: ast.NewIdent(bundle),
	})

	regassets := &ast.CompositeLit{
		Type: ast.NewIdent("map[string]string"),
		Elts: []ast.Expr{},
	}

	for key, value := range gen.assets {
		regassets.Elts = append(regassets.Elts, &ast.KeyValueExpr{
			Key:   &ast.BasicLit{Value: "\"" + key + "\""},
			Value: &ast.BasicLit{Value: "\"" + value + "\""},
		})
	}

	stmt(&ast.ExprStmt{
		X: &ast.CallExpr{
			Fun:  ast.NewIdent("pages.RegisterAssets"),
			Args: []ast.Expr{regassets},
		},
	})

	headfrag := &ast.CallExpr{
		Fun:  ast.NewIdent("html.Frag"),
		Args: []ast.Expr{},
	}
	for _, asset := range gen.head {
		switch asset.typ {
		case "stylesheet":
			headfrag.Args = append(headfrag.Args, ast.NewIdent(fmt.Sprintf(`html.Link(html.Rel("stylesheet"), html.Href(%s))`, asset.path)))
		case "javascript":
			headfrag.Args = append(headfrag.Args, ast.NewIdent(fmt.Sprintf(`html.Script(html.Src(%s))`, asset.path)))
		}
	}
	stmt(&ast.AssignStmt{
		Tok: token.DEFINE,
		Lhs: []ast.Expr{ast.NewIdent("head")},
		Rhs: []ast.Expr{headfrag},
	})

	bodyfrag := &ast.CallExpr{
		Fun:  ast.NewIdent("html.Frag"),
		Args: []ast.Expr{},
	}
	for _, asset := range gen.body {
		switch asset.typ {
		case "stylesheet":
			bodyfrag.Args = append(bodyfrag.Args, ast.NewIdent(fmt.Sprintf(`html.Link(html.Rel("stylesheet"), html.Href(%s))`, asset.path)))
		case "javascript":
			bodyfrag.Args = append(bodyfrag.Args, ast.NewIdent(fmt.Sprintf(`html.Script(html.Src(%s))`, asset.path)))
		}
	}
	stmt(&ast.AssignStmt{
		Tok: token.DEFINE,
		Lhs: []ast.Expr{ast.NewIdent("body")},
		Rhs: []ast.Expr{bodyfrag},
	})

	stmt(&ast.ExprStmt{
		X: ast.NewIdent(middlewares),
	})

	composite := &ast.CompositeLit{
		Type: ast.NewIdent("[]pages.Route"),
		Elts: []ast.Expr{},
	}
	for _, route := range gen.routes {
		var expr ast.Expr
		if route.home {
			expr = ast.NewIdent(fmt.Sprintf(`pages.NewHomeRoute(%s, %s, head, body, %s)`, route.page, route.layout, strings.Join(route.middlewares, ", ")))
		} else {
			if route.redirect {
				expr = ast.NewIdent(fmt.Sprintf(`pages.NewRedirectRoute("%s", "%s", %s, %s)`, route.path, route.to, route.code, strings.Join(route.middlewares, ", ")))
			} else {
				if route.raw {
					expr = ast.NewIdent(fmt.Sprintf(`pages.NewRawRoute("%s", "%s", %s, %s)`, route.path, route.typ, route.content, strings.Join(route.middlewares, ", ")))
				} else {
					expr = ast.NewIdent(fmt.Sprintf(`pages.NewPageRoute("%s", %s, %s, head, body, %s)`, route.path, route.page, route.layout, strings.Join(route.middlewares, ", ")))
				}
			}
		}
		composite.Elts = append(composite.Elts, expr)
	}
	stmt(&ast.AssignStmt{
		Tok: token.DEFINE,
		Lhs: []ast.Expr{ast.NewIdent("routes")},
		Rhs: []ast.Expr{composite},
	})

	stmt(&ast.ExprStmt{
		X: ast.NewIdent(serve),
	})

	stmt(&ast.ReturnStmt{
		Results: []ast.Expr{ast.NewIdent("mux")},
	})

	file.Decls = append(file.Decls, routerfn)

	var buf = new(bytes.Buffer)
	if err := printer.Fprint(buf, fset, file); err != nil {
		return err
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}

	wd, err := os.Getwd()
	if err != nil {
		return err
	}
	root := path.Join(wd, target)
	app := path.Join(root, "app")

	return os.WriteFile(path.Join(app, "app.gen.go"), formatted, 0o644)
}
